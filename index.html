<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mafia - Joc de Rol</title>
  <style>
    /* Reset și stiluri de bază */
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
      font-family: 'Arial', sans-serif; 
    }
    
    body { 
      background: #000000 url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiPjxkZWZzPjxwYXR0ZXJuIGlkPSJwYXR0ZXJuIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgcGF0dGVyblVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgcGF0dGVyblRyYW5zZm9ybT0icm90YXRlKDQ1KSI+PHJlY3QgeD0iMCIgeT0iMCIgd2lkdGg9IjIiIGhlaWdodD0iMiIgZmlsbD0iIzMwMDAwMCIvPjwvcGF0dGVybj48L2RlZnM+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iIzEwMDAwMCIvPjxyZWN0IHdpZHRoPSIxMDAlIiBoZWlnaHQ9IjEwMCUiIGZpbGw9InVybCgjcGF0dGVybikiLz48L3N2Zz4=') fixed;
      color: #e6e6e6; 
      line-height: 1.6; 
      padding: 0;
      max-width: 100%; 
      overflow-x: hidden;
      min-height: 100vh;
      position: relative;
    }
    
    /* Efect de sânge/foc în fundal */
    body::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(200, 0, 0, 0.2) 0%, transparent 40%),
        radial-gradient(circle at 80% 70%, rgba(150, 0, 0, 0.15) 0%, transparent 40%),
        radial-gradient(circle at 40% 80%, rgba(120, 0, 0, 0.1) 0%, transparent 40%);
      z-index: -2;
      pointer-events: none;
    }
    
    .container { 
      max-width: 1200px; 
      margin: 0 auto; 
      padding: 20px; 
      position: relative;
      z-index: 1;
    }
    
    /* Header stilizat dramatic */
    header { 
      text-align: center; 
      padding: 40px 0; 
      background: rgba(0, 0, 0, 0.85);
      margin-bottom: 30px; 
      position: relative;
      border-bottom: 3px solid #ff0000;
      box-shadow: 0 5px 20px rgba(255, 0, 0, 0.3);
    }
    
    header::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 10%;
      right: 10%;
      height: 3px;
      background: linear-gradient(90deg, transparent, #ff0000, transparent);
    }
    
    h1 {
      font-family: 'Times New Roman', serif;
      font-size: 5.5rem;
      font-weight: bold;
      color: #ff0000;
      text-transform: uppercase;
      letter-spacing: 10px;
      text-shadow: 3px 3px 0 #000, 6px 6px 0 rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 0, 0, 0.6);
      margin-bottom: 10px;
      line-height: 1.1;
      position: relative;
      display: inline-block;
    }
    
    h1::before, h1::after {
      content: '♦';
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      color: #ff0000;
      font-size: 2.5rem;
      opacity: 0.8;
    }
    
    h1::before {
      left: -50px;
    }
    
    h1::after {
      right: -50px;
    }
    
    h2 { 
      color: #ff0000; 
      margin: 20px 0; 
      font-size: 1.8rem; 
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
      border-bottom: 1px solid rgba(255, 0, 0, 0.3);
      padding-bottom: 10px;
    }
    
    h3 { 
      color: #ff4444; 
      margin: 15px 0; 
      font-size: 1.4rem; 
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    h4 { 
      color: #ff6666; 
      margin: 12px 0; 
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .screen { 
      display: none; 
      background: rgba(0, 0, 0, 0.85);
      padding: 30px; 
      border-radius: 5px; 
      box-shadow: 0 5px 25px rgba(0, 0, 0, 0.8), 0 0 15px rgba(255, 0, 0, 0.3);
      margin-bottom: 30px; 
      border: 1px solid rgba(255, 0, 0, 0.2);
      position: relative;
      overflow: hidden;
    }
    
    .screen::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, #ff0000, #aa0000, #ff0000);
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.6);
    }
    
    .active { 
      display: block; 
      animation: fadeIn 0.5s ease;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    /* Efect de explozie pentru butoane */
    @keyframes explode {
      0% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
      70% { box-shadow: 0 0 0 20px rgba(255, 0, 0, 0); }
      100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
    }
    
    .btn { 
      display: inline-block; 
      background: linear-gradient(to bottom, #500000, #300000);
      color: white; 
      padding: 10px 15px; 
      border: none; 
      border-radius: 3px; 
      cursor: pointer; 
      font-size: 16px; 
      margin: 10px 5px; 
      transition: all 0.3s; 
      width: 100%; 
      max-width: 300px; 
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5), 0 1px 3px rgba(255, 0, 0, 0.4);
      position: relative;
      overflow: hidden;
      z-index: 1;
    }
    
    .btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, rgba(255,0,0,0.2), transparent);
      z-index: -1;
    }
    
    .btn:hover { 
      transform: translateY(-3px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.6), 0 0 15px rgba(255, 0, 0, 0.5);
    }
    
    .btn:active {
      transform: translateY(1px);
      animation: explode 0.5s forwards;
    }
    
    .btn-primary { 
      background: linear-gradient(to bottom, #ff0000, #aa0000);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    
    .btn-primary:hover { 
      background: linear-gradient(to bottom, #ff3333, #cc0000);
    }
    
    .form-group { 
      margin-bottom: 25px; 
    }
    
    label { 
      display: block; 
      margin-bottom: 10px; 
      font-weight: bold; 
      color: #ff4444; 
      text-transform: uppercase;
      letter-spacing: 1px;
      font-size: 0.9rem;
    }
    
    input[type="text"], 
    input[type="number"] { 
      width: 100%; 
      padding: 14px; 
      border: 1px solid #500000; 
      border-radius: 3px; 
      background-color: rgba(20, 0, 0, 0.7); 
      color: white; 
      font-size: 16px; 
      margin-bottom: 10px; 
      transition: all 0.3s;
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
    }
    
    input[type="text"]:focus, 
    input[type="number"]:focus { 
      outline: none;
      border-color: #ff0000;
      box-shadow: 0 0 0 2px rgba(255, 0, 0, 0.3), inset 0 1px 3px rgba(0, 0, 0, 0.5);
    }
    
    .player-list { 
      list-style-type: none; 
      margin: 25px 0; 
    }
    
    .player-list li { 
      padding: 15px; 
      background: rgba(30, 0, 0, 0.7); 
      margin-bottom: 10px; 
      border-radius: 3px; 
      display: flex; 
      justify-content: space-between; 
      align-items: center; 
      border-left: 4px solid #ff0000; 
      transition: transform 0.2s;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }
    
    .player-list li:hover {
      transform: translateX(5px);
      background: rgba(40, 0, 0, 0.8);
    }
    
    .role-config { 
      margin: 20px 0; 
      padding: 20px; 
      background: rgba(30, 0, 0, 0.7); 
      border-radius: 5px; 
      border: 1px solid rgba(80, 0, 0, 0.5); 
      box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5);
    }
    
    .role-item { 
      display: flex; 
      justify-content: space-between; 
      margin-bottom: 15px; 
      align-items: center; 
      flex-wrap: wrap; 
      gap: 10px;
    }
    
    .role-item input { 
      flex: 1; 
      min-width: 120px;
    }
    
    .role-item button {
      max-width: 100px;
    }
    
    .hidden { 
      display: none; 
    }
    
    #playerScreen { 
      text-align: center; 
      padding: 40px 20px; 
    }
    
    .role-display { 
      font-size: 2.2rem; 
      margin: 40px 0; 
      padding: 30px; 
      background: linear-gradient(135deg, rgba(80, 0, 0, 0.8), rgba(30, 0, 0, 0.9)); 
      border-radius: 5px; 
      display: inline-block; 
      border: 2px solid #ff0000;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); 
      color: #ff0000; 
      font-weight: bold; 
      text-transform: uppercase;
      letter-spacing: 2px;
      position: relative;
      overflow: hidden;
      text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
    }
    
    .role-display::after {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: linear-gradient(
        to bottom right,
        rgba(255, 0, 0, 0) 0%,
        rgba(255, 0, 0, 0.1) 50%,
        rgba(255, 0, 0, 0) 100%
      );
      transform: rotate(30deg);
      animation: shine 3s infinite linear;
    }
    
    @keyframes shine {
      0% { transform: translateX(-100%) rotate(30deg); }
      100% { transform: translateX(100%) rotate(30deg); }
    }
    
    .instructions { 
      background: rgba(30, 0, 0, 0.7); 
      padding: 20px; 
      border-radius: 5px; 
      margin: 20px 0; 
      border-left: 4px solid #ff0000; 
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
    }
    
    .instructions h4 { 
      color: #ff0000; 
      margin-top: 0; 
      margin-bottom: 15px;
    }
    
    .instructions p {
      margin-bottom: 10px;
      padding-left: 10px;
    }
    
    .instructions p:last-child {
      margin-bottom: 0;
    }
    
    .connection-status { 
      padding: 12px; 
      border-radius: 3px; 
      margin: 15px 0; 
      text-align: center; 
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
      background: rgba(198, 40, 40, 0.7);
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }
    
    .connected { 
      background: rgba(236, 177, 15, 0.7); 
    }
    
    .room-code { 
      font-size: 2.2rem; 
      color: #ff0000; 
      font-weight: bold; 
      margin: 20px 0; 
      padding: 15px; 
      background: rgba(30, 0, 0, 0.7); 
      border-radius: 5px; 
      text-align: center; 
      text-shadow: 2px 2px 3px rgba(0,0,0,0.8);
      letter-spacing: 3px;
      border: 1px solid rgba(255, 0, 0, 0.3);
      display: inline-block;
      min-width: 200px;
      box-shadow: 0 0 10px rgba(255, 0, 0, 0.3);
    }
    
    .message-box { 
      background: #ff0000; 
      color: #fff; 
      padding: 15px; 
      border-radius: 3px; 
      margin-bottom: 25px; 
      text-align: center; 
      font-weight: bold; 
      display: none; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      box-shadow: 0 4px 10px rgba(255, 0, 0, 0.3);
    }
    
    /* Efecte de focus și hover pentru butoanele de șters rol */
    .role-item .btn {
      max-width: 100px;
      background: linear-gradient(to bottom, #800000, #600000);
      padding: 10px 15px;
      font-size: 14px;
    }
    
    .role-item .btn:hover {
      background: linear-gradient(to bottom, #a00000, #800000);
    }
    
    /* Media queries pentru design responsive */
    @media (min-width: 768px) { 
      .btn { 
        width: auto; 
      } 
      
      .role-item { 
        flex-wrap: nowrap; 
      }
      
      h1 {
        font-size: 6.5rem;
        letter-spacing: 15px;
      }
    }
    
    @media (max-width: 480px) {
      h1 {
        font-size: 3.5rem;
        letter-spacing: 5px;
      }
      
      h1::before, h1::after {
        display: none;
      }
      
      .screen {
        padding: 20px 15px;
      }
      
      .role-display {
        font-size: 1.6rem;
        padding: 20px;
      }
    }
    
    /* Efect de glont pentru butoane */
    .bullet-hole {
      position: absolute;
      width: 8px;
      height: 8px;
      background: #000;
      border-radius: 50%;
      border: 1px solid #333;
      box-shadow: inset 0 0 3px rgba(255, 0, 0, 0.5);
      pointer-events: none;
      z-index: 10;
    }
    
    /* Imagine de fundal cu poza ta + efecte mafiot */
.mafia-background {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: -1;
    pointer-events: none;

    background: 
        /* poza principală */
        url("https://images.hdqwalls.com/download/mafia-2-definitive-edition-lm-1920x1080.jpg") center/cover no-repeat,

        /* fum / haze */
        radial-gradient(circle at 20% 30%, rgba(255, 0, 0, 0.15), transparent 70%),
        radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.08), transparent 60%),

        /* spot de lumină */
        radial-gradient(circle at 50% 20%, rgba(255,255,255,0.05), transparent 80%),

        /* efect grainy/noise */
        repeating-radial-gradient(circle at 50% 50%, rgba(0,0,0,0.25) 0px, transparent 2px),

        /* fallback dark overlay */
        linear-gradient(to bottom, #0d0d0d, #000000);
    
    background-blend-mode: normal, screen, lighten, overlay, normal;
}

/* Optional: filtru suplimentar pentru textura cinematică */
.mafia-background::after {
    content: "";
    position: absolute;
    inset: 0;
    background: url("https://www.transparenttextures.com/patterns/asfalt-dark.png");
    opacity: 0.15;
    mix-blend-mode: multiply;
}

    
    /* Siluete de mafioți (create cu CSS) */
    .mafia-silhouette {
      position: fixed;
      width: 200px;
      height: 300px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 50% 50% 40% 40%;
      box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
      z-index: -1;
    }
    
    .mafia-silhouette::before {
      content: '';
      position: absolute;
      top: 35%;
      left: 40%;
      width: 20px;
      height: 20px;
      background: #333;
      border-radius: 50%;
      box-shadow: 
        30px 0 0 #333,
        15px -20px 0 -3px #333,
        15px 20px 0 -3px #333;
    }
    
    .mafia-silhouette::after {
      content: '';
      position: absolute;
      bottom: 10%;
      left: 45%;
      width: 10px;
      height: 50px;
      background: #333;
      border-radius: 5px;
      transform: rotate(30deg);
      box-shadow: 20px -10px 0 0 #333;
    }
    
    .mafia-silhouette-1 {
      top: 10%;
      left: 5%;
    }
    
    .mafia-silhouette-2 {
      bottom: 10%;
      right: 5%;
      transform: scaleX(-1);
    }
  </style>
</head>
<body>
  <div class="mafia-background"></div>
  
  <div class="container">
    <header>
      <h1>MAFIA</h1>
    </header>

    <div id="connectionStatus" class="connection-status disconnected">Deconectat</div>

    <!-- Screens -->
    <div id="mainScreen" class="screen active">
      <h2>Bun venit!</h2>
      <p>Pentru a începe, fie creează o cameră nouă, fie alătură-te uneia existente.</p>
      <div class="instructions">
        <h4>Cum funcționează:</h4>
        <p>1. Host-ul creează o cameră și primește un cod</p>
        <p>2. Jucătorii inserează codul camerei pentru a se alătura</p>
        <p>3. Host-ul configurează rolurile și începe jocul</p>
      </div>
      <button id="createRoomBtn" class="btn btn-primary">Creează Cameră</button>
      <button id="joinRoomBtn" class="btn">Alătură-te Camerei</button>
    </div>

    <div id="createRoomScreen" class="screen">
      <h2>Creează o Cameră Nouă</h2>
      <div id="messageBox" class="message-box"></div>
      <div class="form-group">
        <label for="hostName">Numele tău:</label>
        <input type="text" id="hostName" placeholder="Introdu numele tău">
      </div>
      <button id="createRoomConfirmBtn" class="btn btn-primary">Creează Cameră</button>
      <button id="backToMainBtn" class="btn">Înapoi</button>
    </div>

    <div id="joinRoomScreen" class="screen">
      <h2>Alătură-te unei Camere</h2>
      <div id="messageBox2" class="message-box"></div>
      <div class="form-group">
        <label for="playerName">Numele tău:</label>
        <input type="text" id="playerName" placeholder="Introdu numele tău">
      </div>
      <div class="form-group">
        <label for="roomCode">Codul Camerei:</label>
        <input type="text" id="roomCode" placeholder="Introdu codul camerei">
      </div>
      <button id="joinRoomConfirmBtn" class="btn btn-primary">Alătură-te</button>
      <button id="backToMainBtn2" class="btn">Înapoi</button>
    </div>

    <div id="waitingScreen" class="screen">
      <div id="messageBox3" class="message-box"></div>
      <h2>Camera: <span id="displayRoomCode" class="room-code">-</span></h2>
      <h3>Jucători în cameră:</h3>
      <ul id="playersList" class="player-list"></ul>

      <div id="hostControls" class="hidden">
        <h3>Control Host</h3>
        <div class="role-config">
          <h4>Configurează Rolurile</h4>
          <div id="rolesContainer"></div>
          <button id="addRoleBtn" class="btn">Adaugă Rol</button>
        </div>
        <button id="assignRolesBtn" class="btn">Atribuie Roluri Aleatoriu</button>
        <button id="startGameBtn" class="btn btn-primary">Start Joc</button>
      </div>

      <div id="playerWaiting">
        <p>Așteptăm ca host-ul să înceapă jocul...</p>
      </div>
      <div id="pausedMessage" class="message-box hidden" style="background: rgba(255, 179, 0, 0.7);">
        Jocul a fost pus pe pauză de către host. Te rog așteaptă.
      </div>
    </div>

    <div id="playerScreen" class="screen">
      <h2>Salut, <span id="playerNameDisplay">Jucător</span>!</h2>
      <p>Rolul tău în acest joc este:</p>
      <div class="role-display" id="assignedRole">Se atribuie rolurile...</div>
      <p>Baftă!</p>
      <button id="pauseGameBtn" class="btn hidden">Pauză Joc</button>
      <button id="homeBtn" class="btn">Meniu Principal</button>
    </div>
  </div>

  <script type="module">
    // Firebase imports and initialization (unchanged)
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-app.js";
    import { getFirestore, doc, setDoc, onSnapshot, collection, getDoc, updateDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-auth.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore.js";

    // Set Firestore log level for debugging
    setLogLevel('debug');

    // Firebase configuration from your project
    const firebaseConfig = {
      apiKey: "AIzaSyBFchkNH-ccIDfSF8QGJYlGfRi1giNm08A",
      authDomain: "mafia-ffa2d.firebaseapp.com",
      projectId: "mafia-ffa2d",
      storageBucket: "mafia-ffa2d.firebasestorage.app",
      messagingSenderId: "34869116142",
      appId: "1:34869116142:web:5b77e070663e64436bc7ff",
      measurementId: "G-FY6TLT94X9"
    };

    // Initialize Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const appId = "mafia-ffa2d";

    let currentRoomCode = '';
    let isHost = false;
    let playerName = '';
    let playerId = '';
    let roomRef = null;
    let playersRef = null;
    let roomUnsubscribe = null;

    // DOM Elements
    const screens = document.querySelectorAll('.screen');
    const mainScreen = document.getElementById('mainScreen');
    const createRoomScreen = document.getElementById('createRoomScreen');
    const joinRoomScreen = document.getElementById('joinRoomScreen');
    const waitingScreen = document.getElementById('waitingScreen');
    const playerScreen = document.getElementById('playerScreen');
    const connectionStatus = document.getElementById('connectionStatus');
    const hostNameInput = document.getElementById('hostName');
    const playerNameInput = document.getElementById('playerName');
    const roomCodeInput = document.getElementById('roomCode');
    const displayRoomCode = document.getElementById('displayRoomCode');
    const playersList = document.getElementById('playersList');
    const hostControls = document.getElementById('hostControls');
    const playerWaiting = document.getElementById('playerWaiting');
    const rolesContainer = document.getElementById('rolesContainer');
    const assignedRole = document.getElementById('assignedRole');
    const playerNameDisplay = document.getElementById('playerNameDisplay');
    const displayPlayerId = document.getElementById('displayPlayerId');
    const messageBox = document.getElementById('messageBox');
    const messageBox2 = document.getElementById('messageBox2');
    const messageBox3 = document.getElementById('messageBox3');
    const pauseGameBtn = document.getElementById('pauseGameBtn');
    const pausedMessage = document.getElementById('pausedMessage');
    const homeBtn = document.getElementById('homeBtn');

    // 🔐 Anonymous authentication
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        playerId = user.uid;
        updateConnectionStatus(true);
      } else {
        updateConnectionStatus(false);
        await signInAnonymously(auth);
      }
    });

    // 🎮 Event Listeners
    document.getElementById('createRoomBtn').addEventListener('click', () => {
      showScreen(createRoomScreen);
      addDefaultRoles();
    });
    document.getElementById('joinRoomBtn').addEventListener('click', () => showScreen(joinRoomScreen));
    document.getElementById('backToMainBtn').addEventListener('click', () => { messageBox.style.display = 'none'; showScreen(mainScreen); });
    document.getElementById('backToMainBtn2').addEventListener('click', () => { messageBox2.style.display = 'none'; showScreen(mainScreen); });
    document.getElementById('createRoomConfirmBtn').addEventListener('click', createRoom);
    document.getElementById('joinRoomConfirmBtn').addEventListener('click', joinRoom);
    document.getElementById('addRoleBtn').addEventListener('click', () => addRoleRow('', 1));
    document.getElementById('assignRolesBtn').addEventListener('click', assignRoles);
    document.getElementById('startGameBtn').addEventListener('click', startGame);
    pauseGameBtn.addEventListener('click', pauseGame);
    homeBtn.addEventListener('click', leaveRoom);

    // 🌐 UI Functions
    function showScreen(screen) { screens.forEach(s => s.classList.remove('active')); screen.classList.add('active'); }
    function showMessage(element, message) { element.textContent = message; element.style.display = 'block'; setTimeout(() => { element.style.display = 'none'; }, 5000); }
    function generateRoomCode() { return Math.floor(1000 + Math.random() * 9000).toString(); }
    function updateConnectionStatus(connected) { connectionStatus.textContent = connected ? 'Conectat' : 'Deconectat'; connectionStatus.className = connected ? 'connection-status connected' : 'connection-status disconnected'; }

    // 🏠 Create Room
    async function createRoom() {
      const btn = document.getElementById('createRoomConfirmBtn');
      btn.textContent = 'Se încarcă...'; 
      btn.disabled = true;
      try {
        const name = hostNameInput.value.trim();
        if (!name) { 
          showMessage(messageBox, 'Introdu un nume!'); 
          return; 
        }
        playerName = name; 
        isHost = true; 
        currentRoomCode = generateRoomCode();
        
        roomRef = doc(db, `rooms`, currentRoomCode);
        const player = { name: playerName, id: playerId, isHost: true, joinedAt: Date.now(), role: 'Povestitor' };
        await setDoc(roomRef, { 
          code: currentRoomCode, 
          hostId: playerId, 
          status: 'waiting', 
          createdAt: Date.now(),
          players: { [playerId]: player }
        });
        
        displayRoomCode.textContent = currentRoomCode;

        // Listen for player updates and room status changes
        onSnapshot(roomRef, docSnapshot => { 
            if (!docSnapshot.exists()) return;
            const roomData = docSnapshot.data();
            const allPlayers = Object.values(roomData.players || {});
            updatePlayersList(allPlayers);

            if (roomData.status === 'started') {
              const currentPlayer = roomData.players?.[playerId];
              if (currentPlayer?.role) {
                playerNameDisplay.textContent = playerName;
                assignedRole.textContent = currentPlayer.role;
                showScreen(playerScreen);
              }
            } else if (roomData.status === 'waiting') {
              if (!isHost) {
                showScreen(waitingScreen);
                hostControls.classList.add('hidden');
                playerWaiting.classList.remove('hidden');
                pausedMessage.classList.remove('hidden');
              } else {
                  showScreen(waitingScreen);
                  hostControls.classList.remove('hidden');
                  playerWaiting.classList.add('hidden');
                  pausedMessage.classList.add('hidden');
              }
            }
        });
        
        hostControls.classList.remove('hidden'); 
        playerWaiting.classList.add('hidden'); 
        showScreen(waitingScreen);
      } catch (err) { 
        console.error(err); 
        showMessage(messageBox, 'Eroare la crearea camerei.'); 
      } finally { 
        btn.textContent = 'Creează Cameră'; 
        btn.disabled = false; 
      }
    }

    // 👥 Join Room
    async function joinRoom() {
      const btn = document.getElementById('joinRoomConfirmBtn');
      btn.textContent = 'Se încarcă...'; 
      btn.disabled = true;
      try {
        const name = playerNameInput.value.trim(); 
        const code = roomCodeInput.value.trim();
        if (!name) { 
          showMessage(messageBox2, 'Introdu un nume!'); 
          return; 
        }
        if (!code) { 
          showMessage(messageBox2, 'Introdu codul camerei!'); 
          return; 
        }
        
        playerName = name; 
        currentRoomCode = code; 
        isHost = false;
        
        roomRef = doc(db, `rooms`, currentRoomCode); 
        const roomDoc = await getDoc(roomRef);
        
        if (!roomDoc.exists()) { 
          showMessage(messageBox2, 'Camera nu există.'); 
          return; 
        }
        const roomData = roomDoc.data();
        if (roomData.status !== 'waiting' && roomData.status !== 'paused') { 
          showMessage(messageBox2, 'Jocul a început deja.'); 
          return; 
        }

        const newPlayers = { ...roomData.players, [playerId]: { name: playerName, id: playerId, isHost: false, joinedAt: Date.now() } };
        await updateDoc(roomRef, { players: newPlayers });
        
        displayRoomCode.textContent = currentRoomCode;

        // Listen for player updates and room status changes
        onSnapshot(roomRef, docSnapshot => { 
            if (!docSnapshot.exists()) return;
            const roomData = docSnapshot.data();
            const allPlayers = Object.values(roomData.players || {});
            updatePlayersList(allPlayers);

            if (roomData.status === 'started') {
              const currentPlayer = roomData.players?.[playerId];
              if (currentPlayer?.role) {
                playerNameDisplay.textContent = playerName;
                assignedRole.textContent = currentPlayer.role;
                showScreen(playerScreen);
              }
            } else if (roomData.status === 'paused') { 
              showScreen(waitingScreen);
              if (!isHost) {
                hostControls.classList.add('hidden');
                playerWaiting.classList.remove('hidden');
                pausedMessage.classList.remove('hidden');
              } else {
                hostControls.classList.remove('hidden');
                playerWaiting.classList.add('hidden');
                pausedMessage.classList.add('hidden');
              }
            } else if (roomData.status === 'waiting') {
              showScreen(waitingScreen);
              pausedMessage.classList.add('hidden');
              if (isHost) {
                hostControls.classList.remove('hidden');
                playerWaiting.classList.add('hidden');
              } else {
                hostControls.classList.add('hidden');
                playerWaiting.classList.remove('hidden');
              }
            }
        });
        
        hostControls.classList.add('hidden'); 
        playerWaiting.classList.remove('hidden'); 
        showScreen(waitingScreen);
      } catch (err) { 
        console.error(err); 
        showMessage(messageBox2, 'Eroare la conectare.'); 
      } finally { 
        btn.textContent = 'Alătură-te'; 
        btn.disabled = false; 
      }
    }

    // 🔄 Update Player List
    function updatePlayersList(players) {
      playersList.innerHTML = '';
      players.sort((a, b) => a.joinedAt - b.joinedAt);

       players.forEach(p => {
        const li = document.createElement('li');
        let roleText = '';
          if (p.isHost || (isHost && p.role)) {
           roleText = ` (Rol: ${p.role || 'Neatribuit'})`;
          }
          li.innerHTML = `<span>${p.name} ${roleText}</span>`;
          playersList.appendChild(li);
      });
    }

    // ⚙️ Roles Configuration
    function addRoleRow(roleName = '', count = 1) {
      const div = document.createElement('div'); 
      div.className = 'role-item';
      div.innerHTML = `<input type="text" placeholder="Nume rol" value="${roleName}"><input type="number" min="1" value="${count}"><button class="btn">Șterge</button>`;
      div.querySelector('button').addEventListener('click', () => div.remove());
      rolesContainer.appendChild(div);
    }
    
    function addDefaultRoles() { 
      rolesContainer.innerHTML = ''; 
      addRoleRow('Mafiot', 2); 
      addRoleRow('Doctor', 1); 
      addRoleRow('Curva', 1); 
      addRoleRow('Politist', 1); 
      addRoleRow('Cetățean', 4); 
    }

    // 🎲 Assign Roles
    async function assignRoles() {
      try {
        const roomDoc = await getDoc(roomRef);
        const roomData = roomDoc.data();
        const allPlayers = Object.values(roomData.players || {});
        const nonHostPlayers = allPlayers.filter(p => !p.isHost);
        const hostPlayer = allPlayers.find(p => p.isHost);
        
        let roles = [];
        rolesContainer.querySelectorAll('.role-item').forEach(div => {
          const inputs = div.querySelectorAll('input');
          const name = inputs[0].value.trim();
          const count = parseInt(inputs[1].value);
          if (name && count > 0) {
            for (let i = 0; i < count; i++) {
              roles.push(name);
            }
          }
        });

        if (roles.length < nonHostPlayers.length) { 
          showMessage(messageBox3, 'Nu sunt destule roluri pentru toți jucătorii non-host!'); 
          return; 
        }
        
        roles = shuffleArray(roles).slice(0, nonHostPlayers.length);
        
        const playersWithRoles = {};
        nonHostPlayers.forEach((p, i) => { 
          playersWithRoles[p.id] = { ...p, role: roles[i] }; 
        });
        
        // Ensure the host is also in the final object
        if (hostPlayer) {
          playersWithRoles[hostPlayer.id] = { ...hostPlayer, role: 'Povestitor' };
        }

        // Single, atomic write operation to the main room document
        await updateDoc(roomRef, { players: playersWithRoles });
        
        showMessage(messageBox3, 'Rolurile au fost atribuite cu succes!');
      } catch (err) {
        console.error(err);
        showMessage(messageBox3, 'Eroare la atribuirea rolurilor.');
      }
    }

    // 🚀 Start Game
    async function startGame() {
      try {
        const roomDoc = await getDoc(roomRef);
        if (!roomDoc.exists()) {
          showMessage(messageBox3, 'Camera nu mai există.');
          return;
        }

        const playersData = roomDoc.data().players || {};
        const playersArray = Object.values(playersData);
        const hasMafia = playersArray.some(p => p.role === 'Mafiot');

        if (!hasMafia) {
          showMessage(messageBox3, 'Jocul nu poate începe. Nu există niciun mafiot atribuit.');
          return; // Oprește executia funcției
       }

        await updateDoc(roomRef, { status: 'started' });
        showMessage(messageBox3, 'Jocul a început!');
      } catch (err) {
        console.error(err);
        showMessage(messageBox3, 'Eroare la start joc.');
      }
      await updateDoc(roomRef, { status: 'started' });
      if (isHost) {
        pauseGameBtn.classList.remove('hidden');
      }
      showMessage(messageBox3, 'Jocul a început!');
    }

    //  pauseGame
    async function pauseGame() {
      if (!isHost) return;
      try {
        await updateDoc(roomRef, { status: 'waiting' });

        pauseGameBtn.classList.add('hidden');
        showScreen(waitingScreen);
        hostControls.classList.remove('hidden');
        playerWaiting.classList.add('hidden');
        showMessage(messageBox3, 'Jocul este în pauză. Poți modifica rolurile și reporni.');
      } catch (err) {
        console.error(err);
        showMessage(messageBox, 'Eroare la punerea jocului pe pauză.');
      }
    }

    //leaveRoom
    async function leaveRoom() {
      try {
        if (roomRef) {
          const roomDoc = await getDoc(roomRef);
          if (roomDoc.exists()) {
            const playersData = roomDoc.data().players;
            delete playersData[playerId];
            await updateDoc(roomRef, { players: playersData });
            if (roomUnsubscribe) {
              roomUnsubscribe();
              roomUnsubscribe = null;
            }
          }
        }
        currentRoomCode = '';
        isHost = false;
        playerName = '';
        roomRef = null;
        showScreen(mainScreen);
      } catch (err) {
        console.error("Eroare la părăsirea camerei:", err);
      }
    }


    // 🔧 Utilities
    function shuffleArray(a) { 
      for (let i = a.length - 1; i > 0; i--) { 
        const j = Math.floor(Math.random() * (i + 1)); 
        [a[i], a[j]] = [a[j], a[i]]; 
      } 
      return a; 
    }
    
    // Efecte speciale pentru butoane
    document.querySelectorAll('.btn').forEach(btn => {
      btn.addEventListener('click', function(e) {
        // Efect de explozie
        this.style.animation = 'none';
        setTimeout(() => {
          this.style.animation = 'explode 0.5s forwards';
        }, 10);

        setTimeout(() => {
          document.body.removeChild(bulletHole);
        }, 2000);
      });
    });
  </script>
</body>
</html>
